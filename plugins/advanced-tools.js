import { addCommand } from '../lib/plugins.js';
import { log } from '../src/utils/logger.js';
import { withReaction } from '../src/utils/messaging.js';
import { downloadMedia, requireMedia } from '../src/utils/mediaHelper.js';
import { uploadToImgBB } from '../src/utils/uploader.js';
import axios from 'axios';
import path from 'path';

// API Configuration
const API_BASE = global.giftedApiUrl || 'https://api.giftedtech.my.id';
const API_KEY = global.giftedApiKey || '';

/**
 * Generic Screenshot Handler
 */
async function handleScreenshot(m, { conn, args, text }, type) {
    const url = text?.trim();
    if (!url) return m.reply(`‚ùå *Usage:* ${global.prefix}${type} <url>\n*Example:* .${type} https://google.com`);

    await withReaction(conn, m, 'üì∏', async () => {
        try {
            const apiPath = type === 'sspc' ? 'sspc' : (type === 'sstab' ? 'sstab' : 'ssphone');
            const res = await axios.get(`${API_BASE}/api/tools/${apiPath}`, {
                params: { apikey: API_KEY, url: url },
                responseType: 'arraybuffer'
            });

            const mode = type === 'sspc' ? 'Desktop' : (type === 'sstab' ? 'Tablet' : 'Mobile');

            await conn.sendMessage(m.chat, {
                image: Buffer.from(res.data),
                caption: `‚ú® *Mantra Screenshot*\n${global.divider}\nüåê *URL:* ${url}\nüì± *Mode:* ${mode}\n\n_Generated by Mantra_`
            }, { quoted: m });

        } catch (error) {
            log.error(`Screenshot (${type}) failed`, error);
            throw new Error(`Failed to capture screenshot. ${error.message}`);
        }
    });
}

// --- SCREENSHOT COMMANDS ---
addCommand({ pattern: 'ssphone', alias: ['ssmobile', 'phoness'], desc: 'Take mobile screenshot of a website', category: 'tools', handler: async (m, context) => handleScreenshot(m, context, 'ssphone') });
addCommand({ pattern: 'sstab', alias: ['sstablet', 'tabletss'], desc: 'Take tablet screenshot of a website', category: 'tools', handler: async (m, context) => handleScreenshot(m, context, 'sstab') });
addCommand({ pattern: 'sspc', alias: ['pcss', 'desktopss'], desc: 'Take PC screenshot of a website', category: 'tools', handler: async (m, context) => handleScreenshot(m, context, 'sspc') });

// --- QR TOOLS ---
addCommand({
    pattern: 'createqr',
    alias: ['toqr', 'qrcode'],
    desc: 'Create a QR code from text or link',
    category: 'tools',
    handler: async (m, { conn, text }) => {
        let content = text?.trim();
        if (!content && m.quoted) {
            content = m.quoted.body || m.quoted.text;
        }

        if (!content) return m.reply(`‚ùå Please provide text or a link.\n\n*Usage:* .createqr Hello\n*Or:* Reply to a text message with .createqr`);

        await withReaction(conn, m, 'üì≤', async () => {
            try {
                const res = await axios.get(`${API_BASE}/api/tools/createqr`, {
                    params: { apikey: API_KEY, query: content },
                    responseType: 'arraybuffer'
                });

                await conn.sendMessage(m.chat, {
                    image: Buffer.from(res.data),
                    caption: `‚ú® *Mantra QR Code*\n${global.divider}\nüìù *Data:* ${content.substring(0, 100)}${content.length > 100 ? '...' : ''}`
                }, { quoted: m });
            } catch (error) {
                log.error('Create QR failed', error);
                throw error;
            }
        });
    }
});

addCommand({
    pattern: 'readqr',
    alias: ['scanqr', 'decodeqr'],
    desc: 'Read/decode a QR code from an image',
    category: 'tools',
    handler: async (m, { conn }) => {
        const target = requireMedia(m, m.quoted, ['image']);
        if (!target) return;

        await withReaction(conn, m, 'üîç', async () => {
            try {
                const buffer = await downloadMedia(target);
                const upload = await uploadToImgBB(buffer);

                const res = await axios.get(`${API_BASE}/api/tools/readqr`, {
                    params: { apikey: API_KEY, url: upload.url }
                });

                if (!res.data?.success) throw new Error('No QR code found in image');

                const rawResult = res.data.result || res.data.data;
                const qrContent = typeof rawResult === 'object' ? (rawResult.qrcode_data || rawResult.data || JSON.stringify(rawResult)) : rawResult;

                await conn.sendMessage(m.chat, {
                    text: `‚ú® *Mantra QR Reader*\n${global.divider}\nüì± *Content:*\n\n${qrContent}`,
                    buttons: [
                        {
                            name: 'cta_copy',
                            buttonParamsJson: JSON.stringify({
                                display_text: 'Copy Content üìã',
                                copy_code: qrContent
                            })
                        }
                    ],
                    headerType: 1
                }, { quoted: m });

            } catch (error) {
                log.error('Read QR failed', error);
                throw error;
            }
        });
    }
});

// --- RENAME FILE ---
addCommand({
    pattern: 'rename',
    alias: ['rn', 'filename'],
    desc: 'Rename a quoted file/media',
    category: 'tools',
    handler: async (m, { conn, text }) => {
        if (!m.quoted) return m.reply('‚ùå Please reply to a document or media file.');

        const newName = text?.trim();
        if (!newName) return m.reply('‚ùå Please provide a new filename.\n\n*Example:* .rename my_video.mp4');

        await withReaction(conn, m, 'üìù', async () => {
            try {
                const buffer = await downloadMedia(m.quoted);
                const mime = m.quoted.mimetype || 'application/octet-stream';

                // Extract original extension if name doesn't have one
                let finalName = newName;
                if (!finalName.includes('.')) {
                    const originalName = m.quoted.message?.documentMessage?.fileName || '';
                    const ext = path.extname(originalName) || '';
                    finalName += ext;
                }

                await conn.sendMessage(m.chat, {
                    document: buffer,
                    fileName: finalName,
                    mimetype: mime
                }, { quoted: m });

            } catch (error) {
                log.error('Rename failed', error);
                throw error;
            }
        });
    }
});

// --- FANCY TEXT ---
addCommand({
    pattern: 'fancy',
    alias: ['fonts', 'font'],
    desc: 'Convert text to fancy styles',
    category: 'tools',
    handler: async (m, { conn, text, commandName }) => {
        const input = text?.trim();
        if (!input) return m.reply(`‚ùå *Usage:* .fancy <text>\n*Example:* .fancy Mantra Bot`);

        await withReaction(conn, m, '‚ú®', async () => {
            try {
                const res = await axios.get(`${API_BASE}/api/tools/fancy`, {
                    params: { apikey: API_KEY, text: input }
                });

                if (!res.data?.success || !res.data?.results) throw new Error('Failed to generate styles');

                const results = res.data.results;

                // Handle specific fancy style (e.g. .fancy4)
                const numMatch = commandName.match(/fancy(\d+)/i);
                if (numMatch) {
                    const index = parseInt(numMatch[1]) - 1;
                    if (index >= 0 && index < results.length) {
                        const selected = results[index];
                        return m.reply(`‚ú® *Style:* ${selected.name}\n\n${selected.result}`);
                    }
                }

                // Default list view
                let txt = `‚ú® *Mantra Fancy Fonts*\n${global.divider}\nüìù *Input:* ${input}\n\n`;
                results.forEach((r, i) => {
                    txt += `*${i + 1}.* ${r.result}\n`;
                });
                txt += `\nüí° Tip: Use .fancy<number> to copy a style\nExample: .fancy5 ${input}`;

                await m.reply(txt);

            } catch (error) {
                log.error('Fancy text failed', error);
                throw error;
            }
        });
    }
});

// --- OTHERS ---
addCommand({
    pattern: 'ttp',
    desc: 'Convert text to sticker',
    category: 'tools',
    handler: async (m, { conn, text }) => {
        if (!text) return m.reply('‚ùå Please provide text.');
        await withReaction(conn, m, 'üé®', async () => {
            const res = await axios.get(`${API_BASE}/api/tools/ttp`, { params: { apikey: API_KEY, query: text } });
            if (!res.data?.success || !res.data?.image_url) throw new Error('Failed to create text image');

            const imgRes = await axios.get(res.data.image_url, { responseType: 'arraybuffer' });
            await conn.sendMessage(m.chat, {
                sticker: Buffer.from(imgRes.data),
                packname: global.packname,
                author: global.author
            }, { quoted: m });
        });
    }
});

addCommand({
    pattern: 'define',
    alias: ['meaning', 'urban'],
    desc: 'Get word definition',
    category: 'tools',
    handler: async (m, { conn, text }) => {
        if (!text) return m.reply('‚ùå Please provide a word.');
        await withReaction(conn, m, 'üìñ', async () => {
            const res = await axios.get(`${API_BASE}/api/tools/define`, { params: { apikey: API_KEY, term: text } });
            if (!res.data?.success || !res.data?.results?.length) throw new Error('No definitions found');

            const def = res.data.results[0];
            const txt = `‚ú® *Mantra Dictionary*\n${global.divider}\nüìñ *Word:* ${def.word}\n\nüìù *Definition:* ${def.definition.replace(/\[|\]/g, '')}\n\nüí¨ *Example:* _"${def.example?.replace(/\[|\]/g, '') || 'N/A'}"_\n\nüë§ *Author:* ${def.author}`;
            await m.reply(txt);
        });
    }
});

addCommand({
    pattern: 'emojimix',
    alias: ['mix'],
    desc: 'Mix two emojis',
    category: 'tools',
    handler: async (m, { conn, text }) => {
        if (!text) return m.reply('‚ùå Use: .mix üòÇüôÑ');
        await withReaction(conn, m, 'üòÄ', async () => {
            const emojis = text.match(/(\p{Emoji_Presentation}|\p{Emoji}\uFE0F)/gu);
            if (!emojis || emojis.length < 2) throw new Error('Provide 2 emojis');

            const res = await axios.get(`${API_BASE}/api/tools/emojimix`, {
                params: { apikey: API_KEY, emoji1: emojis[0], emoji2: emojis[1] },
                responseType: 'arraybuffer'
            });

            await conn.sendMessage(m.chat, { image: Buffer.from(res.data), caption: `‚ú® *Mantra Emoji Mix*\n${emojis[0]} + ${emojis[1]}` }, { quoted: m });
        });
    }
});

addCommand({
    pattern: 'web2zip',
    desc: 'Download website as ZIP',
    category: 'tools',
    handler: async (m, { conn, text }) => {
        if (!text) return m.reply('‚ùå Provide URL');
        await withReaction(conn, m, 'üì¶', async () => {
            const res = await axios.get(`${API_BASE}/api/tools/web2zip`, {
                params: { apikey: API_KEY, url: text },
                responseType: 'arraybuffer'
            });

            let name = 'website';
            try { name = new URL(text).hostname.replace(/\./g, '_'); } catch (e) { }

            await conn.sendMessage(m.chat, {
                document: Buffer.from(res.data),
                fileName: `${name}.zip`,
                mimetype: 'application/zip',
                caption: `‚ú® *Mantra Web2Zip*\nüåê ${text}`
            }, { quoted: m });
        });
    }
});

log.action('Advanced Tools plugin loaded', 'system');
